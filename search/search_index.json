{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"D-Land Zu den Tutorials","title":"Home"},{"location":"#d-land","text":"Zu den Tutorials","title":"D-Land"},{"location":"about/","text":"\u00dcber Anmerkungen, Kommentare und Feedback","title":"\u00dcber"},{"location":"about/#uber","text":"Anmerkungen, Kommentare und Feedback","title":"\u00dcber"},{"location":"tutorials/","text":"Grundlagen Installation DMD Kompiler auf Windows Installation LDC auf Windows Subsystem f\u00fcr Linux Coff Import Bibliotheken erstellen Cloud Native AWS Elastic Beanstalk Applikationen Sichere Docker images f\u00fcr cloud Anwendungen erstellen Datenbanken SQLite: Erste Schritte Gui HTML5 Anwendungen mit GTK3 schreiben","title":"\u00dcbersicht"},{"location":"tutorials/#grundlagen","text":"Installation DMD Kompiler auf Windows Installation LDC auf Windows Subsystem f\u00fcr Linux Coff Import Bibliotheken erstellen","title":"Grundlagen"},{"location":"tutorials/#cloud","text":"Native AWS Elastic Beanstalk Applikationen Sichere Docker images f\u00fcr cloud Anwendungen erstellen","title":"Cloud"},{"location":"tutorials/#datenbanken","text":"SQLite: Erste Schritte","title":"Datenbanken"},{"location":"tutorials/#gui","text":"HTML5 Anwendungen mit GTK3 schreiben","title":"Gui"},{"location":"tutorials/cloud/","text":"Cloud Native AWS Elastic Beanstalk Applikationen Sichere Docker images f\u00fcr cloud Anwendungen erstellen","title":"\u00dcbersicht"},{"location":"tutorials/cloud/#cloud","text":"Native AWS Elastic Beanstalk Applikationen Sichere Docker images f\u00fcr cloud Anwendungen erstellen","title":"Cloud"},{"location":"tutorials/cloud/native-aws-beanstalk-applikationen/","text":"Native AWS Elastic Beanstalk Applikationen Es gibt 2 M\u00f6glichkeiten in D geschriebene Anwendungen auf AWS Elastic Beanstalk zu verwenden. Eine M\u00f6glichkeit ist die D Anwendung als Docker Container in Elastic Beanstalk auszuf\u00fchren. Die zweite M\u00f6glichkeit ist als Platform Go anzugeben und die D Anwendung innerhalb eines ZIP Archivs an Elastic Beanstalk zu \u00fcbergeben. Dieses Tutorial beschreibt die Verwendung der Go Platform. Voraussetzung f\u00fcr dieses Tutorial ist die Installation von LDC auf WSL . Webserver-Umgebung Erstelle eine neue Datei application.d mit folgendem Inhalt: /+ dub.sdl: name \"application\" dependency \"vibe-d:http\" version=\"0.8.6-alpha.2\" dependency \"vibe-d:tls\" version=\"*\" subConfiguration \"vibe-d:tls\" \"notls\" +/ import vibe . core . core : runApplication ; import vibe . http . server ; void main () { listenHTTP ( \":5000\" , & handleRequest ); runApplication (); } void handleRequest ( HTTPServerRequest req , HTTPServerResponse res ) { if ( req . path == \"/\" ) res . writeBody ( \"Hello, World!\" ); } Mit Hilfe von vibe.d wird ein HTTP Server auf dem Port 5000 gestartet. AWS Elastic Beanstalk erwartet eine unter Linux ausf\u00fchrbare Datei. Starte eine Windows Kommandozeile und gib folgenden Befehl ein. wsl dub build --single application.d -b plain Eine unter Linux ausf\u00fchrbare Datei mit dem Namen application wurde erstellt. F\u00fchre diesen Befehl aus um deine Applikation in eine Zip Datei zu packen: wsl zip -r app.zip ./application Dadurch dass das Linux Tool zip verwendet wird, beh\u00e4lt die Datei application auch die Information, dass es sich um eine ausf\u00fchrbare Datei handelt. Auf AWS Elastic Beanstalk kannst du nun eine neue Webserver-Umgebung anlegen, als Platform Go w\u00e4hlen und die Datei app.zip ausw\u00e4hlen. Worker-Umgebung AWS gibt in seiner aktuellen Dokumentation an, dass SQS Nachrichten als HTTP requests an Port 80 der Server Anwendungen geschickt werden. F\u00fcr die Go Platform ist das nicht korrekt. Hier muss die Server Anwendung, wie auch bei der Webserver-Umgebung, auf Port 5000 eingestellt sein. In diesem Beispiel benutze ich die HTTP Server Komponente arsd-official:cgi . /+ dub.sdl: name \"application\" dependency \"arsd-official:cgi\" version=\"4.0.1\" subConfiguration \"arsd-official:cgi\" \"embedded_httpd\" +/ import arsd . cgi ; void main () { cgiMainImpl !( handle , Cgi , defaultMaxContentLength )([ \"--port\" , \"5000\" ]); } void handle ( Cgi cgi ) { if ( cgi . requestMethod == cgi . RequestMethod . POST && cgi . requestUri == \"/\" ) { string json = cgi . postJson ; cgi . setResponseStatus ( \"200 OK\" ); } else cgi . setResponseStatus ( \"404 File Not Found\" ); } Auch hier wird wieder ein HTTP Server auf Port 5000 gestartet. Den Inhalt der SQS Message wird in der Variable json gespeichert und kann weiter ausgewertet werden. Genauso wie bei der Webserver Elastic Beanstalk Anwendung muss die Applikation wieder unter Linux kompiliert und in eine Zip Datei gepackt werden. .ebextensions \u00dcber Konfigurationsdateien in einem Ordner .ebextensions k\u00f6nnen Startparameter f\u00fcr die AWS Elastic Beanstalk Applikation gesetzt werden. Falls z.B. die Anwendung unter Windows in ein Zip Archiv gepackt wurde, geht das Executable Kennzeichen verloren. Dieses Kennzeichen kann nachtr\u00e4glich wieder gesetzt werden, wie im folgenden Beispiel beschrieben. Erstelle einen Ordner mit dem Namen .ebextensions und eine Datei set_perms.config innerhalb dieses Ordners mit folgendem Inhalt: container_commands : set_perms : command : \"chmod 777 application\" F\u00fcge den Ordner .ebextensions dem Zip Archiv hinzu.","title":"Native AWS Elastic Beanstalk Applikationen"},{"location":"tutorials/cloud/native-aws-beanstalk-applikationen/#native-aws-elastic-beanstalk-applikationen","text":"Es gibt 2 M\u00f6glichkeiten in D geschriebene Anwendungen auf AWS Elastic Beanstalk zu verwenden. Eine M\u00f6glichkeit ist die D Anwendung als Docker Container in Elastic Beanstalk auszuf\u00fchren. Die zweite M\u00f6glichkeit ist als Platform Go anzugeben und die D Anwendung innerhalb eines ZIP Archivs an Elastic Beanstalk zu \u00fcbergeben. Dieses Tutorial beschreibt die Verwendung der Go Platform. Voraussetzung f\u00fcr dieses Tutorial ist die Installation von LDC auf WSL .","title":"Native AWS Elastic Beanstalk Applikationen"},{"location":"tutorials/cloud/native-aws-beanstalk-applikationen/#webserver-umgebung","text":"Erstelle eine neue Datei application.d mit folgendem Inhalt: /+ dub.sdl: name \"application\" dependency \"vibe-d:http\" version=\"0.8.6-alpha.2\" dependency \"vibe-d:tls\" version=\"*\" subConfiguration \"vibe-d:tls\" \"notls\" +/ import vibe . core . core : runApplication ; import vibe . http . server ; void main () { listenHTTP ( \":5000\" , & handleRequest ); runApplication (); } void handleRequest ( HTTPServerRequest req , HTTPServerResponse res ) { if ( req . path == \"/\" ) res . writeBody ( \"Hello, World!\" ); } Mit Hilfe von vibe.d wird ein HTTP Server auf dem Port 5000 gestartet. AWS Elastic Beanstalk erwartet eine unter Linux ausf\u00fchrbare Datei. Starte eine Windows Kommandozeile und gib folgenden Befehl ein. wsl dub build --single application.d -b plain Eine unter Linux ausf\u00fchrbare Datei mit dem Namen application wurde erstellt. F\u00fchre diesen Befehl aus um deine Applikation in eine Zip Datei zu packen: wsl zip -r app.zip ./application Dadurch dass das Linux Tool zip verwendet wird, beh\u00e4lt die Datei application auch die Information, dass es sich um eine ausf\u00fchrbare Datei handelt. Auf AWS Elastic Beanstalk kannst du nun eine neue Webserver-Umgebung anlegen, als Platform Go w\u00e4hlen und die Datei app.zip ausw\u00e4hlen.","title":"Webserver-Umgebung"},{"location":"tutorials/cloud/native-aws-beanstalk-applikationen/#worker-umgebung","text":"AWS gibt in seiner aktuellen Dokumentation an, dass SQS Nachrichten als HTTP requests an Port 80 der Server Anwendungen geschickt werden. F\u00fcr die Go Platform ist das nicht korrekt. Hier muss die Server Anwendung, wie auch bei der Webserver-Umgebung, auf Port 5000 eingestellt sein. In diesem Beispiel benutze ich die HTTP Server Komponente arsd-official:cgi . /+ dub.sdl: name \"application\" dependency \"arsd-official:cgi\" version=\"4.0.1\" subConfiguration \"arsd-official:cgi\" \"embedded_httpd\" +/ import arsd . cgi ; void main () { cgiMainImpl !( handle , Cgi , defaultMaxContentLength )([ \"--port\" , \"5000\" ]); } void handle ( Cgi cgi ) { if ( cgi . requestMethod == cgi . RequestMethod . POST && cgi . requestUri == \"/\" ) { string json = cgi . postJson ; cgi . setResponseStatus ( \"200 OK\" ); } else cgi . setResponseStatus ( \"404 File Not Found\" ); } Auch hier wird wieder ein HTTP Server auf Port 5000 gestartet. Den Inhalt der SQS Message wird in der Variable json gespeichert und kann weiter ausgewertet werden. Genauso wie bei der Webserver Elastic Beanstalk Anwendung muss die Applikation wieder unter Linux kompiliert und in eine Zip Datei gepackt werden.","title":"Worker-Umgebung"},{"location":"tutorials/cloud/native-aws-beanstalk-applikationen/#ebextensions","text":"\u00dcber Konfigurationsdateien in einem Ordner .ebextensions k\u00f6nnen Startparameter f\u00fcr die AWS Elastic Beanstalk Applikation gesetzt werden. Falls z.B. die Anwendung unter Windows in ein Zip Archiv gepackt wurde, geht das Executable Kennzeichen verloren. Dieses Kennzeichen kann nachtr\u00e4glich wieder gesetzt werden, wie im folgenden Beispiel beschrieben. Erstelle einen Ordner mit dem Namen .ebextensions und eine Datei set_perms.config innerhalb dieses Ordners mit folgendem Inhalt: container_commands : set_perms : command : \"chmod 777 application\" F\u00fcge den Ordner .ebextensions dem Zip Archiv hinzu.","title":".ebextensions"},{"location":"tutorials/cloud/sichere-docker-images-fuer-cloud-anwendungen-erstellen/","text":"Sichere Docker images f\u00fcr cloud Anwendungen erstellen Docker images k\u00f6nnen leicht mehrere hundert MB gro\u00df werden. W\u00e4hrend die Gr\u00f6\u00dfe bei der \u00dcbertragung nur st\u00f6rend ist, stellen die vielen unn\u00f6tigen Komponenten ein Sicherheitsproblem dar. Jede zus\u00e4tzliche Komponente erh\u00f6ht die Angriffsfl\u00e4che und damit die Gefahr auf einen erfolgreichen Angriff. Ein Docker image sollte keine interaktiven tools wie z.B. bash enthalten, sondern nur die Komponenten, die f\u00fcr den Betrieb unverzichtbar sind. Durch die Verwendung des Docker scratch image, wird genau dieses Ziel erreicht. Das scratch image enth\u00e4lt ein minimales Linux System ohne jegliche weitere Komponenten. Dieses Tutorial zeigt anhand einer http server Anwendung, wie ein sicheres Docker image f\u00fcr den cloud Betrieb erstellt werden kann. Erstelle eine Datei app.d mit diesem Inhalt: /+ dub.sdl: name \"app\" dependency \"vibe-d:http\" version=\"0.8.6\" dependency \"vibe-d:tls\" version=\"*\" subConfiguration \"vibe-d:tls\" \"openssl-1.1\" +/ import std . process : environment ; import vibe . core . core : runApplication ; import vibe . http . server ; void main () { string port = environment . get ( \"PORT\" , \"8080\" ); listenHTTP ( \"0.0.0.0:\" ~ port , & handleRequest ); runApplication (); } private void handleRequest ( HTTPServerRequest req , HTTPServerResponse res ) { if ( req . path == \"/\" ) res . writeBody ( \"Hello, World!\" ); } Die Umgebungsvariable PORT wird ausgelesen und der http Server f\u00fcr diesen Port gestartet. Falls die Umgebungsvariable nicht definiert ist, wird als Port 8080 verwendet. Erstelle eine Datei Dockerfile mit diesem Inhalt: FROM ubuntu:focal as base RUN apt-get update && apt-get upgrade -y \\ && apt-get install --no-install-recommends -y build-essential ldc dub zlib1g-dev libssl-dev COPY app.d /tmp RUN dub build --single /tmp/app.d RUN mkdir -p /dist/opt/ && cp /tmp/app /dist/opt/ WORKDIR /dist RUN { ldd /dist/opt/app ; } | tr -s '[:blank:]' '\\n' | grep '^/' | \\ xargs -I % sh -c 'mkdir -p $(dirname ./%); cp % ./%;' FROM scratch as final COPY --chown = 0 :0 --from = base /dist / COPY --from = base /etc/passwd /etc/passwd COPY --from = base /etc/group /etc/group USER www-data ENV LD_LIBRARY_PATH = /lib/x86_64-linux-gnu:/lib64:/usr/lib/x86_64-linux-gnu CMD [ \"/opt/app\" ] Das Dockerfile besteht aus den zwei stages base und final . Im stage base wird der LDC compiler und zus\u00e4tzliche Abh\u00e4ngigkeiten installiert. Danach wird die http server Anwendung kompiliert und nach /dist/opt/ kopiert. Am Ende von stage base werden alle zus\u00e4tzlichen Abh\u00e4ngigkeiten (Dynamische Bibliotheken) der Anwendung ermittelt und in ein Unterverzeichnis von /dist/ kopiert. Nur die Dateien, die sich im stage final befinden, werden auch im Docker image verf\u00fcgbar sein. Der Inhalt von /dist wird aus dem base stage nach final kopiert. Um die Sicherheit weiter zu erh\u00f6hen, wird der Benutzer www-data gesetzt. Dies erfordert, das zuvor die Dateien /etc/passwd und /etc/group aus stage base nach final kopiert werden. Stage final endet mit der Angabe, unter welchen Pfaden die dynamischen Bibliotheken zu finden sind und die http server Anwendung wird als Docker image Startanwendung gesetzt. \u00d6ffne eine Kommandozeile und erstelle das Docker image mit docker build . Danach starte einen container mit docker run : docker build -t sample . docker run -it --rm -p 8080 :8080 sample \u00d6ffne einen webbrowser. Der http server ist unter der Adresse http://localhost:8080 erreichbar. Alpine als Basis Im vorrigen Beispiel basierte der stage base auf der Linux Distribution Ubuntu . Statt dessen kann aber auch eine andere Linux Distribution, wie z.B. Alpine genommen werden. An dem Dockerfile \u00e4ndern sich nur Kleinigkeiten. Die Paketverwaltung hat einen anderen Namen und auch die Pakete selbst hei\u00dfen anders. Auch muss der Benutzer www-data und die dazu geh\u00f6rige Gruppe www-data angelegt werden. FROM alpine:3.12 as base RUN apk add --update alpine-sdk ldc dub openssl-dev zlib-dev COPY app.d /tmp RUN dub build --single /tmp/app.d RUN mkdir -p /dist/opt/ && cp /tmp/app /dist/opt/ WORKDIR /dist RUN { ldd /dist/opt/app ; } | tr -s '[:blank:]' '\\n' | grep '^/' | \\ xargs -I % sh -c 'mkdir -p $(dirname ./%); cp % ./%;' RUN set -x ; \\ addgroup -g 82 -S www-data ; \\ adduser -u 82 -D -S -G www-data www-data && exit 0 ; exit 1 FROM scratch as final COPY --chown = 0 :0 --from = base /dist / COPY --from = base /etc/passwd /etc/passwd COPY --from = base /etc/group /etc/group USER www-data ENV LD_LIBRARY_PATH = /lib/x86_64-linux-gnu:/lib64:/usr/lib/x86_64-linux-gnu CMD [ \"/opt/app\" ]","title":"Sichere Docker images f\u00fcr cloud Anwendungen erstellen"},{"location":"tutorials/cloud/sichere-docker-images-fuer-cloud-anwendungen-erstellen/#sichere-docker-images-fur-cloud-anwendungen-erstellen","text":"Docker images k\u00f6nnen leicht mehrere hundert MB gro\u00df werden. W\u00e4hrend die Gr\u00f6\u00dfe bei der \u00dcbertragung nur st\u00f6rend ist, stellen die vielen unn\u00f6tigen Komponenten ein Sicherheitsproblem dar. Jede zus\u00e4tzliche Komponente erh\u00f6ht die Angriffsfl\u00e4che und damit die Gefahr auf einen erfolgreichen Angriff. Ein Docker image sollte keine interaktiven tools wie z.B. bash enthalten, sondern nur die Komponenten, die f\u00fcr den Betrieb unverzichtbar sind. Durch die Verwendung des Docker scratch image, wird genau dieses Ziel erreicht. Das scratch image enth\u00e4lt ein minimales Linux System ohne jegliche weitere Komponenten. Dieses Tutorial zeigt anhand einer http server Anwendung, wie ein sicheres Docker image f\u00fcr den cloud Betrieb erstellt werden kann. Erstelle eine Datei app.d mit diesem Inhalt: /+ dub.sdl: name \"app\" dependency \"vibe-d:http\" version=\"0.8.6\" dependency \"vibe-d:tls\" version=\"*\" subConfiguration \"vibe-d:tls\" \"openssl-1.1\" +/ import std . process : environment ; import vibe . core . core : runApplication ; import vibe . http . server ; void main () { string port = environment . get ( \"PORT\" , \"8080\" ); listenHTTP ( \"0.0.0.0:\" ~ port , & handleRequest ); runApplication (); } private void handleRequest ( HTTPServerRequest req , HTTPServerResponse res ) { if ( req . path == \"/\" ) res . writeBody ( \"Hello, World!\" ); } Die Umgebungsvariable PORT wird ausgelesen und der http Server f\u00fcr diesen Port gestartet. Falls die Umgebungsvariable nicht definiert ist, wird als Port 8080 verwendet. Erstelle eine Datei Dockerfile mit diesem Inhalt: FROM ubuntu:focal as base RUN apt-get update && apt-get upgrade -y \\ && apt-get install --no-install-recommends -y build-essential ldc dub zlib1g-dev libssl-dev COPY app.d /tmp RUN dub build --single /tmp/app.d RUN mkdir -p /dist/opt/ && cp /tmp/app /dist/opt/ WORKDIR /dist RUN { ldd /dist/opt/app ; } | tr -s '[:blank:]' '\\n' | grep '^/' | \\ xargs -I % sh -c 'mkdir -p $(dirname ./%); cp % ./%;' FROM scratch as final COPY --chown = 0 :0 --from = base /dist / COPY --from = base /etc/passwd /etc/passwd COPY --from = base /etc/group /etc/group USER www-data ENV LD_LIBRARY_PATH = /lib/x86_64-linux-gnu:/lib64:/usr/lib/x86_64-linux-gnu CMD [ \"/opt/app\" ] Das Dockerfile besteht aus den zwei stages base und final . Im stage base wird der LDC compiler und zus\u00e4tzliche Abh\u00e4ngigkeiten installiert. Danach wird die http server Anwendung kompiliert und nach /dist/opt/ kopiert. Am Ende von stage base werden alle zus\u00e4tzlichen Abh\u00e4ngigkeiten (Dynamische Bibliotheken) der Anwendung ermittelt und in ein Unterverzeichnis von /dist/ kopiert. Nur die Dateien, die sich im stage final befinden, werden auch im Docker image verf\u00fcgbar sein. Der Inhalt von /dist wird aus dem base stage nach final kopiert. Um die Sicherheit weiter zu erh\u00f6hen, wird der Benutzer www-data gesetzt. Dies erfordert, das zuvor die Dateien /etc/passwd und /etc/group aus stage base nach final kopiert werden. Stage final endet mit der Angabe, unter welchen Pfaden die dynamischen Bibliotheken zu finden sind und die http server Anwendung wird als Docker image Startanwendung gesetzt. \u00d6ffne eine Kommandozeile und erstelle das Docker image mit docker build . Danach starte einen container mit docker run : docker build -t sample . docker run -it --rm -p 8080 :8080 sample \u00d6ffne einen webbrowser. Der http server ist unter der Adresse http://localhost:8080 erreichbar.","title":"Sichere Docker images f\u00fcr cloud Anwendungen erstellen"},{"location":"tutorials/cloud/sichere-docker-images-fuer-cloud-anwendungen-erstellen/#alpine-als-basis","text":"Im vorrigen Beispiel basierte der stage base auf der Linux Distribution Ubuntu . Statt dessen kann aber auch eine andere Linux Distribution, wie z.B. Alpine genommen werden. An dem Dockerfile \u00e4ndern sich nur Kleinigkeiten. Die Paketverwaltung hat einen anderen Namen und auch die Pakete selbst hei\u00dfen anders. Auch muss der Benutzer www-data und die dazu geh\u00f6rige Gruppe www-data angelegt werden. FROM alpine:3.12 as base RUN apk add --update alpine-sdk ldc dub openssl-dev zlib-dev COPY app.d /tmp RUN dub build --single /tmp/app.d RUN mkdir -p /dist/opt/ && cp /tmp/app /dist/opt/ WORKDIR /dist RUN { ldd /dist/opt/app ; } | tr -s '[:blank:]' '\\n' | grep '^/' | \\ xargs -I % sh -c 'mkdir -p $(dirname ./%); cp % ./%;' RUN set -x ; \\ addgroup -g 82 -S www-data ; \\ adduser -u 82 -D -S -G www-data www-data && exit 0 ; exit 1 FROM scratch as final COPY --chown = 0 :0 --from = base /dist / COPY --from = base /etc/passwd /etc/passwd COPY --from = base /etc/group /etc/group USER www-data ENV LD_LIBRARY_PATH = /lib/x86_64-linux-gnu:/lib64:/usr/lib/x86_64-linux-gnu CMD [ \"/opt/app\" ]","title":"Alpine als Basis"},{"location":"tutorials/datenbanken/","text":"Datenbanken SQLite: Erste Schritte","title":"\u00dcbersicht"},{"location":"tutorials/datenbanken/#datenbanken","text":"SQLite: Erste Schritte","title":"Datenbanken"},{"location":"tutorials/datenbanken/sqlite-erste-schritte/","text":"SQLite: Erste Schritte SQLite ist eine schlanke und kostenlose Datenbank, die dennoch f\u00fcr die meisten Anwendungsf\u00e4lle ausreichend ist. Lege einen neuen Ordner an und nenne ihn z.B. sqlitedemo1 . Auf der Seite https://www.sqlite.org/download.html findest du unter der \u00dcberschrift Precompiled Binaries for Windows ein Zip Archiv, dessen Namen mit sqlite-dll-win64-x64- beginnt, gefolgt von der aktuellen Version. Lade dieses Zip und kopiere die DLL Datei aus dem Archiv in den Ordner sqlitedemo1 . F\u00fcr den Zugriff auf die Funktionen der SQLite DLL ben\u00f6tigst du eine statische Import Bibliothek. Siehe hierzu das Tutorial Coff Import Bibliotheken erstellen . F\u00fcr D gibt es verschiedene Bibliotheken um auf SQLite zuzugreifen. In diesem Beispiel nutze ich die arsd-official Bibliothek . Erstelle eine neue Datei application.d mit folgenden Inhalt.: /+ dub.sdl: name \"application\" dependency \"arsd-official:sqlite\" version=\"4.2.0\" +/ import std ; import arsd . sqlite ; void main () { Database db = new Sqlite ( \"demo.db\" ); auto result = db . query ( `SELECT name FROM sqlite_master WHERE type='table' AND name=?` , \"recipients\" ); if ( result . empty ) { db . query ( `CREATE TABLE recipients ( ID INTEGER PRIMARY KEY AUTOINCREMENT, FIRST_NAME TEXT NOT NULL, LAST_NAME TEXT NOT NULL )` ); db . query ( `INSERT INTO recipients (FIRST_NAME, LAST_NAME) VALUES (?, ?);` , \"John\" , \"Doe\" ); } foreach ( row ; db . query ( `SELECT * FROM recipients` )) { writeln ( row ); } readln (); } Es wird eine SQLite Verbindung zu der Datei demo.db aufgebaut. Falls diese Datei noch nicht existiert, wird sie im aktuellen Verzeichnis angelegt. Danach wird gepr\u00fcft, ob die Tabelle recipients existiert. Falls nicht, wird auch diese angelegt und danach ein neuer Datensatz eingef\u00fcgt. Am Ende werden alle Datens\u00e4tze aus der Tabelle recipients ausgegeben. Die Anwendung wird mit diesem Befehl erzeugt und gestartet: dub application.d Wenn du deine Anwendung weitergeben m\u00f6chtest musst du die EXE + die DLL weitergeben.","title":"SQLite: Erste Schritte"},{"location":"tutorials/datenbanken/sqlite-erste-schritte/#sqlite-erste-schritte","text":"SQLite ist eine schlanke und kostenlose Datenbank, die dennoch f\u00fcr die meisten Anwendungsf\u00e4lle ausreichend ist. Lege einen neuen Ordner an und nenne ihn z.B. sqlitedemo1 . Auf der Seite https://www.sqlite.org/download.html findest du unter der \u00dcberschrift Precompiled Binaries for Windows ein Zip Archiv, dessen Namen mit sqlite-dll-win64-x64- beginnt, gefolgt von der aktuellen Version. Lade dieses Zip und kopiere die DLL Datei aus dem Archiv in den Ordner sqlitedemo1 . F\u00fcr den Zugriff auf die Funktionen der SQLite DLL ben\u00f6tigst du eine statische Import Bibliothek. Siehe hierzu das Tutorial Coff Import Bibliotheken erstellen . F\u00fcr D gibt es verschiedene Bibliotheken um auf SQLite zuzugreifen. In diesem Beispiel nutze ich die arsd-official Bibliothek . Erstelle eine neue Datei application.d mit folgenden Inhalt.: /+ dub.sdl: name \"application\" dependency \"arsd-official:sqlite\" version=\"4.2.0\" +/ import std ; import arsd . sqlite ; void main () { Database db = new Sqlite ( \"demo.db\" ); auto result = db . query ( `SELECT name FROM sqlite_master WHERE type='table' AND name=?` , \"recipients\" ); if ( result . empty ) { db . query ( `CREATE TABLE recipients ( ID INTEGER PRIMARY KEY AUTOINCREMENT, FIRST_NAME TEXT NOT NULL, LAST_NAME TEXT NOT NULL )` ); db . query ( `INSERT INTO recipients (FIRST_NAME, LAST_NAME) VALUES (?, ?);` , \"John\" , \"Doe\" ); } foreach ( row ; db . query ( `SELECT * FROM recipients` )) { writeln ( row ); } readln (); } Es wird eine SQLite Verbindung zu der Datei demo.db aufgebaut. Falls diese Datei noch nicht existiert, wird sie im aktuellen Verzeichnis angelegt. Danach wird gepr\u00fcft, ob die Tabelle recipients existiert. Falls nicht, wird auch diese angelegt und danach ein neuer Datensatz eingef\u00fcgt. Am Ende werden alle Datens\u00e4tze aus der Tabelle recipients ausgegeben. Die Anwendung wird mit diesem Befehl erzeugt und gestartet: dub application.d Wenn du deine Anwendung weitergeben m\u00f6chtest musst du die EXE + die DLL weitergeben.","title":"SQLite: Erste Schritte"},{"location":"tutorials/grundlagen/","text":"Grundlagen Installation DMD Kompiler auf Windows Installation LDC auf Windows Subsystem f\u00fcr Linux Coff Import Bibliotheken erstellen","title":"\u00dcbersicht"},{"location":"tutorials/grundlagen/#grundlagen","text":"Installation DMD Kompiler auf Windows Installation LDC auf Windows Subsystem f\u00fcr Linux Coff Import Bibliotheken erstellen","title":"Grundlagen"},{"location":"tutorials/grundlagen/coff-import-bibliotheken-erstellen/","text":"Coff Import Bibliotheken erstellen Um auf Funktionen zuzugreifen, die in einer Windows DLL bereit gestellt werden, gibt es einmal die M\u00f6glichkeit eine statische Import Bibliothek zu erstellen oder dynamisch auf die Funktionen zuzugreifen. Dieses Tutorial beschreibt, wie f\u00fcr eine DLL eine statische Coff Import Bibliothek erstellt werden kann. Installation In dem Archiv llvm-9.0.0-windows-x64.7z befindet sich im Verzeichnis bin die Datei llvm-dlltool.exe . Entpacke diese Datei auf deinen PC und f\u00fcge den Pfad zu der Datei, zur Umgebungsvariable PATH hinzu. Verwendung In diesem Beispiel wird eine Import Bibliothek f\u00fcr SQLite erstellt. Lade von https://www.sqlite.org/download.html das Zip Archive 64-bit DLL (x64) for SQLite auf deinen PC und entpacke die DLL und die DEF Datei. In der Windows Kommandozeile f\u00fchre diesen Befehl aus, um f\u00fcr die DLL sqlite3.dll und die DEF Datei sqlite3.def eine Import Bibliothek mit dem Namen sqlite3.lib und der Architektur x86_64 zu erstellen. llvm-dlltool.exe -D sqlite3.dll -d sqlite3.def -l sqlite3.lib -m i386:x86-64","title":"Coff Import Bibliotheken erstellen"},{"location":"tutorials/grundlagen/coff-import-bibliotheken-erstellen/#coff-import-bibliotheken-erstellen","text":"Um auf Funktionen zuzugreifen, die in einer Windows DLL bereit gestellt werden, gibt es einmal die M\u00f6glichkeit eine statische Import Bibliothek zu erstellen oder dynamisch auf die Funktionen zuzugreifen. Dieses Tutorial beschreibt, wie f\u00fcr eine DLL eine statische Coff Import Bibliothek erstellt werden kann.","title":"Coff Import Bibliotheken erstellen"},{"location":"tutorials/grundlagen/coff-import-bibliotheken-erstellen/#installation","text":"In dem Archiv llvm-9.0.0-windows-x64.7z befindet sich im Verzeichnis bin die Datei llvm-dlltool.exe . Entpacke diese Datei auf deinen PC und f\u00fcge den Pfad zu der Datei, zur Umgebungsvariable PATH hinzu.","title":"Installation"},{"location":"tutorials/grundlagen/coff-import-bibliotheken-erstellen/#verwendung","text":"In diesem Beispiel wird eine Import Bibliothek f\u00fcr SQLite erstellt. Lade von https://www.sqlite.org/download.html das Zip Archive 64-bit DLL (x64) for SQLite auf deinen PC und entpacke die DLL und die DEF Datei. In der Windows Kommandozeile f\u00fchre diesen Befehl aus, um f\u00fcr die DLL sqlite3.dll und die DEF Datei sqlite3.def eine Import Bibliothek mit dem Namen sqlite3.lib und der Architektur x86_64 zu erstellen. llvm-dlltool.exe -D sqlite3.dll -d sqlite3.def -l sqlite3.lib -m i386:x86-64","title":"Verwendung"},{"location":"tutorials/grundlagen/installation-dmd-kompiler-auf-windows/","text":"Installation DMD Kompiler auf Windows Installation Lade von https://dlang.org/download.html den DMD Kompiler f\u00fcr Windows im 7z Archivformat. Entpacke das Archiv nach C:\\D . Danach f\u00fcge den Pfad C:\\D\\dmd2\\windows\\bin zu der Windows Umgebungsvariable PATH hinzu. Installationstest Erstelle eine neue Datei mit dem Namen helloworld.d und folgenden Inhalt: import std . stdio ; void main () { writeln ( \"Hello World!\" ); } Mit diesem Befehl wird der Quellcode kompiliert und die Anwendung direkt gestartet: dmd -run helloworld.d","title":"Installation DMD Kompiler auf Windows"},{"location":"tutorials/grundlagen/installation-dmd-kompiler-auf-windows/#installation-dmd-kompiler-auf-windows","text":"","title":"Installation DMD Kompiler auf Windows"},{"location":"tutorials/grundlagen/installation-dmd-kompiler-auf-windows/#installation","text":"Lade von https://dlang.org/download.html den DMD Kompiler f\u00fcr Windows im 7z Archivformat. Entpacke das Archiv nach C:\\D . Danach f\u00fcge den Pfad C:\\D\\dmd2\\windows\\bin zu der Windows Umgebungsvariable PATH hinzu.","title":"Installation"},{"location":"tutorials/grundlagen/installation-dmd-kompiler-auf-windows/#installationstest","text":"Erstelle eine neue Datei mit dem Namen helloworld.d und folgenden Inhalt: import std . stdio ; void main () { writeln ( \"Hello World!\" ); } Mit diesem Befehl wird der Quellcode kompiliert und die Anwendung direkt gestartet: dmd -run helloworld.d","title":"Installationstest"},{"location":"tutorials/grundlagen/installation-ldc-auf-windows-subsystem-fuer-linux/","text":"Installation LDC auf Windows Subsystem f\u00fcr Linux Windows Subsystem f\u00fcr Linux installieren Starte den Microsoft Store \u00fcber Windows Start und der Eingabe Store . Suche nach Ubuntu 18.04 LTS . Klicke auf Herunterladen und danach auf Starten . Ubuntu ist kostenlos verf\u00fcgbar, eine Anmeldung im Store ist nicht notwendig. Starte Windows Powershell als Administrator und f\u00fchre diesen Befehl aus: Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux Im Windows Startmen\u00fc starte die Anwendung Ubuntu 18.04 LTS . Beim ersten Start kann ein Benutzername und Passwort vergeben werden. F\u00fchre danach diesen Befehl aus um verschiedene Entwickler Pakete zu installieren: sudo apt-get update && sudo apt-get install --yes build-essential LDC installieren F\u00fchre in der Ubuntu Bash diesen Befehl aus um den Download von LDC 1.18.0 zu starten. curl -OL https://github.com/ldc-developers/ldc/releases/download/v1.18.0/ldc2-1.18.0-linux-x86_64.tar.xz Mit dem Befehl tar kann das Archiv entpackt werden. Danach kann das nicht mehr ben\u00f6tigte Archiv mit dem Befehl rm gel\u00f6scht werden. tar -xf ldc2-1.18.0-linux-x86_64.tar.xz rm ldc2-1.18.0-linux-x86_64.tar.xz F\u00fcge den Pfad ./ldc2-1.18.0-linux-x86_64/bin zur Umgebungsvariable PATH hinzu, indem du die Datei ~/.profile editierst. In diesem Beispiel wird diese Zeile angeh\u00e4ngt: PATH = $PATH :/home/user/ldc2-1.18.0-linux-x86_64/bin Installationstest Lege unter Windows eine Datei helloworld.d und diesem Inhalt an: import std . stdio ; void main () { writeln ( \"Hello World!\" ); } \u00d6ffne eine DOS Konsole und gib diesen Befehl ein um die Anwendung unter Linux zu Kompilieren und zu Starten: wsl ldc2 -run helloworld.d","title":"Installation LDC auf Windows Subsystem f\u00fcr Linux"},{"location":"tutorials/grundlagen/installation-ldc-auf-windows-subsystem-fuer-linux/#installation-ldc-auf-windows-subsystem-fur-linux","text":"","title":"Installation LDC auf Windows Subsystem f\u00fcr Linux"},{"location":"tutorials/grundlagen/installation-ldc-auf-windows-subsystem-fuer-linux/#windows-subsystem-fur-linux-installieren","text":"Starte den Microsoft Store \u00fcber Windows Start und der Eingabe Store . Suche nach Ubuntu 18.04 LTS . Klicke auf Herunterladen und danach auf Starten . Ubuntu ist kostenlos verf\u00fcgbar, eine Anmeldung im Store ist nicht notwendig. Starte Windows Powershell als Administrator und f\u00fchre diesen Befehl aus: Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux Im Windows Startmen\u00fc starte die Anwendung Ubuntu 18.04 LTS . Beim ersten Start kann ein Benutzername und Passwort vergeben werden. F\u00fchre danach diesen Befehl aus um verschiedene Entwickler Pakete zu installieren: sudo apt-get update && sudo apt-get install --yes build-essential","title":"Windows Subsystem f\u00fcr Linux installieren"},{"location":"tutorials/grundlagen/installation-ldc-auf-windows-subsystem-fuer-linux/#ldc-installieren","text":"F\u00fchre in der Ubuntu Bash diesen Befehl aus um den Download von LDC 1.18.0 zu starten. curl -OL https://github.com/ldc-developers/ldc/releases/download/v1.18.0/ldc2-1.18.0-linux-x86_64.tar.xz Mit dem Befehl tar kann das Archiv entpackt werden. Danach kann das nicht mehr ben\u00f6tigte Archiv mit dem Befehl rm gel\u00f6scht werden. tar -xf ldc2-1.18.0-linux-x86_64.tar.xz rm ldc2-1.18.0-linux-x86_64.tar.xz F\u00fcge den Pfad ./ldc2-1.18.0-linux-x86_64/bin zur Umgebungsvariable PATH hinzu, indem du die Datei ~/.profile editierst. In diesem Beispiel wird diese Zeile angeh\u00e4ngt: PATH = $PATH :/home/user/ldc2-1.18.0-linux-x86_64/bin","title":"LDC installieren"},{"location":"tutorials/grundlagen/installation-ldc-auf-windows-subsystem-fuer-linux/#installationstest","text":"Lege unter Windows eine Datei helloworld.d und diesem Inhalt an: import std . stdio ; void main () { writeln ( \"Hello World!\" ); } \u00d6ffne eine DOS Konsole und gib diesen Befehl ein um die Anwendung unter Linux zu Kompilieren und zu Starten: wsl ldc2 -run helloworld.d","title":"Installationstest"},{"location":"tutorials/gui/","text":"Gui HTML5 Anwendungen mit GTK3 schreiben","title":"\u00dcbersicht"},{"location":"tutorials/gui/#gui","text":"HTML5 Anwendungen mit GTK3 schreiben","title":"Gui"},{"location":"tutorials/gui/html5-anwendungen-mit-gtk3-schreiben/","text":"HTML5 Anwendungen mit GTK3 schreiben GTK3 ist zwar prim\u00e4r f\u00fcr die Erstellung von Desktop Anwendungen gedacht, mit der Erweiterung Broadway lassen sich Anwendungen aber auch im Browser darstellen. Um Betriebssystem unabh\u00e4ngig zu sein, lassen wir Broadway und die GTK3 Anwendung in einem docker container laufen. Erstelle eine Datei app.d mit folgendem Inhalt: iimport core . runtime : Runtime ; import std . algorithm , std . array , std . conv ; import gtk ; pragma ( lib , \"gtk-3\" ); pragma ( lib , \"glib-2.0\" ); pragma ( lib , \"pango-1.0\" ); pragma ( lib , \"gobject-2.0\" ); pragma ( lib , \"cairo\" ); pragma ( lib , \"atk-1.0\" ); pragma ( lib , \"gio-2.0\" ); void activate ( GtkApplication * app , gpointer user_data ) { GtkWidget * window ; window = gtk_application_window_new ( app ); gtk_window_set_title ( cast ( GtkWindow *) window , \"Window\" ); gtk_window_set_default_size ( cast ( GtkWindow *) window , 200 , 200 ); gtk_widget_show_all ( window ); } int main () { GtkApplication * app ; int status ; app = gtk_application_new ( \"org.gtk.example\" , G_APPLICATION_FLAGS_NONE ); g_signal_connect_object ( app , \"activate\" , cast ( GCallback ) & activate , NULL , G_CONNECT_SWAPPED ); status = g_application_run ( cast ( GApplication *) app , Runtime . cArgs . argc , Runtime . cArgs . argv ); g_object_unref ( app ); return status ; } Dieses coding zeigt ein leeres Fenster an und ist eine \u00dcbersetzung von der C Beispiel Anwendung nach D. Erstelle eine Datei gtk.dpp mit diesem Inhalt: #include <gtk/gtk.h> Das Modul gtk.dpp erm\u00f6glicht den Zugriff auf die C header Dateien von GTK3. Erstelle eine Datei Dockerfile mit diesem Inhalt: FROM dlang2/ldc-ubuntu:1.19.0 as base RUN apt-get update && apt-get upgrade -y \\ && apt-get install -y clang-9 libclang-9-dev libgtk-3-dev \\ && apt-get clean \\ && rm -rf /var/lib/apt/lists/* RUN ln -s /usr/bin/clang-9 /usr/bin/clang COPY gtk.dpp /tmp/ RUN DFLAGS = \"-L=-L/usr/lib/llvm-9/lib/\" dub run dpp -- /tmp/gtk.dpp \\ --include-path /usr/include/gtk-3.0 \\ --include-path /usr/include/glib-2.0 \\ --include-path /usr/include/pango-1.0 \\ --include-path /usr/include/cairo \\ --include-path /usr/include/gdk-pixbuf-2.0 \\ --include-path /usr/include/atk-1.0 \\ --include-path /usr/lib/x86_64-linux-gnu/glib-2.0/include \\ --preprocess-only COPY app.d /tmp/ RUN DFLAGS = \"-L=-L/usr/lib/x86_64-linux-gnu/\" ldc2 /tmp/app.d /tmp/gtk.d -of = /tmp/app ############################################################################### ## final image FROM debian:buster-slim RUN apt-get update && apt-get upgrade -y \\ && apt-get install -y libgtk-3-0 \\ && apt-get clean \\ && rm -rf /var/lib/apt/lists/* COPY --from = base /tmp/app /tmp/app COPY start.sh /tmp/ CMD [ \"/tmp/start.sh\" ] Das docker image wird in 2 Phasen gebaut. In Phase 1 wird DPP verwendet um aus den GTK3 C header Dateien ein D Modul gtk.d zu erzeugen. Dieser Schritt kann einige Minuten dauern. Das generierte Modul gtk.d wird zusammen mit dem Modul app.d zu einer ausf\u00fchrbaren Datei /tmp/app kompiliert. In Phase 2 wird die ausf\u00fchrbare Datei /tmp/app aus Phase 1 r\u00fcber kopiert und das shell script start.sh als container Startkommando gesetzt. Erstelle eine Datei start.sh mit diesem Inhalt: #!/bin/sh export GDK_BACKEND broadway broadwayd -p 8889 :0 & /tmp/app Das shell script start.sh setzt die Umgebungsvariable GDK_BACKEND auf broadway . Damit wird die HTML5 Ausgabe aktiviert. Die server Komponente broadwayd wird im Hintergrund gestartet. Zuletzt wird die eigentliche Anwendung /tmp/app gestartet. Baue das docker image mit dem Befehl: docker build -t t1 . und starte danach einen container mit diesem Befehl: docker run -p 8889 :8889 t1 Im browser kannst du die Anwendung unter der Adresse http://localhost:8889 aufrufen.","title":"HTML5 Anwendungen mit GTK3 schreiben"},{"location":"tutorials/gui/html5-anwendungen-mit-gtk3-schreiben/#html5-anwendungen-mit-gtk3-schreiben","text":"GTK3 ist zwar prim\u00e4r f\u00fcr die Erstellung von Desktop Anwendungen gedacht, mit der Erweiterung Broadway lassen sich Anwendungen aber auch im Browser darstellen. Um Betriebssystem unabh\u00e4ngig zu sein, lassen wir Broadway und die GTK3 Anwendung in einem docker container laufen. Erstelle eine Datei app.d mit folgendem Inhalt: iimport core . runtime : Runtime ; import std . algorithm , std . array , std . conv ; import gtk ; pragma ( lib , \"gtk-3\" ); pragma ( lib , \"glib-2.0\" ); pragma ( lib , \"pango-1.0\" ); pragma ( lib , \"gobject-2.0\" ); pragma ( lib , \"cairo\" ); pragma ( lib , \"atk-1.0\" ); pragma ( lib , \"gio-2.0\" ); void activate ( GtkApplication * app , gpointer user_data ) { GtkWidget * window ; window = gtk_application_window_new ( app ); gtk_window_set_title ( cast ( GtkWindow *) window , \"Window\" ); gtk_window_set_default_size ( cast ( GtkWindow *) window , 200 , 200 ); gtk_widget_show_all ( window ); } int main () { GtkApplication * app ; int status ; app = gtk_application_new ( \"org.gtk.example\" , G_APPLICATION_FLAGS_NONE ); g_signal_connect_object ( app , \"activate\" , cast ( GCallback ) & activate , NULL , G_CONNECT_SWAPPED ); status = g_application_run ( cast ( GApplication *) app , Runtime . cArgs . argc , Runtime . cArgs . argv ); g_object_unref ( app ); return status ; } Dieses coding zeigt ein leeres Fenster an und ist eine \u00dcbersetzung von der C Beispiel Anwendung nach D. Erstelle eine Datei gtk.dpp mit diesem Inhalt: #include <gtk/gtk.h> Das Modul gtk.dpp erm\u00f6glicht den Zugriff auf die C header Dateien von GTK3. Erstelle eine Datei Dockerfile mit diesem Inhalt: FROM dlang2/ldc-ubuntu:1.19.0 as base RUN apt-get update && apt-get upgrade -y \\ && apt-get install -y clang-9 libclang-9-dev libgtk-3-dev \\ && apt-get clean \\ && rm -rf /var/lib/apt/lists/* RUN ln -s /usr/bin/clang-9 /usr/bin/clang COPY gtk.dpp /tmp/ RUN DFLAGS = \"-L=-L/usr/lib/llvm-9/lib/\" dub run dpp -- /tmp/gtk.dpp \\ --include-path /usr/include/gtk-3.0 \\ --include-path /usr/include/glib-2.0 \\ --include-path /usr/include/pango-1.0 \\ --include-path /usr/include/cairo \\ --include-path /usr/include/gdk-pixbuf-2.0 \\ --include-path /usr/include/atk-1.0 \\ --include-path /usr/lib/x86_64-linux-gnu/glib-2.0/include \\ --preprocess-only COPY app.d /tmp/ RUN DFLAGS = \"-L=-L/usr/lib/x86_64-linux-gnu/\" ldc2 /tmp/app.d /tmp/gtk.d -of = /tmp/app ############################################################################### ## final image FROM debian:buster-slim RUN apt-get update && apt-get upgrade -y \\ && apt-get install -y libgtk-3-0 \\ && apt-get clean \\ && rm -rf /var/lib/apt/lists/* COPY --from = base /tmp/app /tmp/app COPY start.sh /tmp/ CMD [ \"/tmp/start.sh\" ] Das docker image wird in 2 Phasen gebaut. In Phase 1 wird DPP verwendet um aus den GTK3 C header Dateien ein D Modul gtk.d zu erzeugen. Dieser Schritt kann einige Minuten dauern. Das generierte Modul gtk.d wird zusammen mit dem Modul app.d zu einer ausf\u00fchrbaren Datei /tmp/app kompiliert. In Phase 2 wird die ausf\u00fchrbare Datei /tmp/app aus Phase 1 r\u00fcber kopiert und das shell script start.sh als container Startkommando gesetzt. Erstelle eine Datei start.sh mit diesem Inhalt: #!/bin/sh export GDK_BACKEND broadway broadwayd -p 8889 :0 & /tmp/app Das shell script start.sh setzt die Umgebungsvariable GDK_BACKEND auf broadway . Damit wird die HTML5 Ausgabe aktiviert. Die server Komponente broadwayd wird im Hintergrund gestartet. Zuletzt wird die eigentliche Anwendung /tmp/app gestartet. Baue das docker image mit dem Befehl: docker build -t t1 . und starte danach einen container mit diesem Befehl: docker run -p 8889 :8889 t1 Im browser kannst du die Anwendung unter der Adresse http://localhost:8889 aufrufen.","title":"HTML5 Anwendungen mit GTK3 schreiben"}]}